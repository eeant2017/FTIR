//==================================================================================================
//| 文件名称 | Pub_Fun.c
//|--------- |--------------------------------------------------------------------------------------
//| 文件描述 | Pub_Fun.c源文件
//|--------- |--------------------------------------------------------------------------------------
//| 版权声明 | Copyright2009, 聚光科技(FPI)
//|----------|--------------------------------------------------------------------------------------
//|  版本    |  时间       |  作者     | 描述
//|--------- |-------------|-----------|------------------------------------------------------------
//|  V1.1    | 2009.04.24  | Gang  | 规范化
//==================================================================================================
#include <stdlib.h>

#include "Pub_Fun.h"


//NTC-10KPX3-42H-S1热敏电阻的温度表
#define NTC_TABLE_LEN	32
const FP32 gar_NtcTable[NTC_TABLE_LEN][2]=
{
        {519910,-55},{379890,-50},{280700,-45},{209600,-40},{158090,-35},{120370,-30},{92484,-25},
        {71668,-20}, {55993,-15}, {44087,-10}, {34971,-5},  {27936,0},   {22468,5},   {18187,10},
        {14813,15},	 {12136,20},  {10000,25},  {8284,30},   {6899,35},   {5774,40},	  {4856,45},
        {4103,50},	 {3482,55},	  {2967,60},   {2539,65},   {2182,70},   {1882,75},   {1629,80},
        {1415,85},   {1234,90},   {1079,95},   {946.6,100},
};
const float RT_code[] =
{
        //0   1     2     3     4     5     6     7     8     9
        70.03,66.66,63.47,60.45,57.60,54.89,52.33,49.90,47.60,45.42,//-20
        43.35,41.38,39.52,37.75,36.07,34.48,32.96,31.62,30.16,28.85,//-10
        27.62,26.44,25.32,24.25,23.23,22.27,21.34,20.46,19.63,18.83,//0
        18.07,17.34,16.65,15.98,15.35,14.75,14.17,13.62,13.09,12.59,//10
        12.11,11.65,11.21,10.79,10.39,10.00,9.631,9.277,8.938,8.613,//20
        8.302,8.004,7.718,7.444,7.180,6.928,6.686,6.454,6.230,6.016,//30
        5.810,5.613,5.423,5.240,5.065,4.897,4.734,4.578,4.429,4.284,//40
        4.145,4.012,3.833,3.759,3.640,3.525,3.415,3.308,3.205,3.106,//50
        3.011,2.919,2.830,2.744,2.662,2.582,2.505,2.431,2.359,2.290,//60
        2.223,2.158,2.096,2.036,1.978,1.921,1.867,1.814,1.764,1.714 //70
};


FP32 CalOnTemp(FP32 f_v)
{
        FP32 f_r;
//	FP32 f_t;

        INT8U t1,t2,i;

        t1 = 0;
        t2 = 99;
        //获得电阻值
        f_r = (FP32)((f_v*10)/(2.5 - f_v));

        //温度查表算法，折中查表
        if((f_r >= 2.158) && (f_r <= 73.60))
        {
                while(t2 != (t1+1))
                {
                        i = (INT8U)((t1+t2)>>1);

                        if(RT_code[i] > f_r)
                        {
                                t1 = i;
                        }
                        else
                        {
                                t2 = i;
                        }
                }

                return((FP32)t2-(f_r-RT_code[t2])/(RT_code[t1]-RT_code[t2])-20);
        }
        else
        {
                return(70.0);
        }
}
//==================================================================================================
//| 函数名称 | PRTInt32u
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 把整数按ASCII码打印到缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ar_buf -- 打印缓冲区， uin_data -- 打印的值
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 当前字符串在缓冲区中'\0'的索引
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
INT16U PRTInt32u(INT8U *ar_buf, INT32U uin_data)
{
    INT32U i = 1000000000;
    INT16U j = 0;
    INT8U uch_tmp;
    INT8U uch_first = 0;

    do
    {
        uch_tmp = (INT8U)(uin_data/i);
        uin_data %= i;
        if(uch_tmp > 0)
        {
            ar_buf[j++] = '0' + uch_tmp;
            uch_first = 1;
        }
        else if(uch_first == 1)
        {
                ar_buf[j++] = '0';
        }

        i /= 10;
    } while (i > 0);

    if(j == 0)
    {
        ar_buf[j++] = '0';
    }

    ar_buf[j] = '\0';

    return j;
}

//==================================================================================================
//| 函数名称 | PRTFp32
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 把浮点数按ASCII码打印到缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ar_buf -- 打印缓冲区， f_data -- 打印的值
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 当前字符串在缓冲区中'\0'的索引
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
INT16U PRTFp32(INT8U *ar_buf, FP32 f_data, INT8U uch_dig)
{
    FP32 f_dig;
    INT32S sin_int;
    INT32U i = 1000000000;
    INT16U j = 0;
    INT16U k;
    INT8U uch_tmp;
    INT8U uch_first = 0;

    if(f_data > 4294967296 / 2)
    {
        return 0;
    }

        if(f_data < 0)
        {
                ar_buf[j++] = '-';
                f_data = -f_data;
        }

    sin_int = (INT32S)f_data;
    f_dig = f_data - sin_int;

    do
    {
        uch_tmp = (INT8U)(sin_int/i);
        sin_int %= i;
        if(uch_tmp > 0)
        {
            ar_buf[j++] = '0' + uch_tmp;
            uch_first = 1;
        }
        else if(uch_first == 1)
        {
                ar_buf[j++] = '0';
        }
        i /= 10;
    } while (i > 0);

    if((j == 0) || (ar_buf[j-1] == '-'))
    {
        ar_buf[j++] = '0';
    }

    ar_buf[j++] = '.';

        k = j;
        uch_first = uch_dig;

        i = 1;
    while(uch_dig-- > 0)
    {
        f_dig *= 10;
        i *= 10;
    }
    i /= 10;
    f_dig += 0.5;

    sin_int = (INT32S)f_dig;

    while(uch_first-- > 0)
    {
        uch_tmp = (INT8U)(sin_int/i);
        sin_int %= i;
        ar_buf[j++] = '0' + uch_tmp;

        i /= 10;
    }

        if(k == j)
        {
                ar_buf[j++] = '0';
        }
    ar_buf[j] = '\0';

    return j;
}

//==================================================================================================
//| 函数名称 | SRTIncInt32u
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 排序
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_data -- 指针， ul_num -- 数目
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
void SRTIncInt32u(INT32U *p_data, INT32U ul_num)
{
        INT32U i, j;
        INT32U ul_tmp;

        if(p_data == NULL || ul_num < 2)
        {
                return;
        }


        for(i = 0; i < ul_num - 1; i++)
        {
                for(j = 0; j < ul_num - i; j++)
                {
                        if(p_data[j] > p_data[j + 1])
                        {
                                ul_tmp = p_data[j];
                                p_data[j] = p_data[j+1];
                                p_data[j+1] = ul_tmp;
                        }
                }
        }
}
//==================================================================================================
//| 函数名称 | SRTIncFp32
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 排序
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_data -- 指针， ul_num -- 数目
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
void SRTIncFp32(FP32 *p_data, INT32U ul_num)
{
        INT32U i, j;
        FP32 f_tmp;

        if(p_data == NULL || ul_num < 2)
        {
                return;
        }


        for(i = 0; i < ul_num - 1; i++)
        {
                for(j = 0; j < ul_num - i; j++)
                {
                        if(p_data[j] > p_data[j + 1])
                        {
                                f_tmp = p_data[j];
                                p_data[j] = p_data[j+1];
                                p_data[j+1] = f_tmp;
                        }
                }
        }
}


//==================================================================================================
//| 函数名称 | DLYMs
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 延时
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ul_time
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
void DLYMs(INT32U ul_time)
{
    while ( ul_time-- > 0 )
    {
        #if 0
        DLYUs(1950); // RAM
        #else
        DLYUs(1860);//FLASH
        #endif
    }
}

//==================================================================================================
//| 函数名称 | DLYUs
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 延时
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ul_time
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
void DLYUs(INT32U ul_time)
{

}

//==================================================================================================
//| 函数名称 | EncodeFloat
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 将FP32数据按照大小端格式编码到缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | f1 -- 欲编码浮点数， p -- 编码缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
void EncodeFloat(FP32 f1, INT8U *p)
{
        TYPECHANGE u_Temp;
        u_Temp.f_FloatData = f1;
        p[0] = u_Temp.bit.byte0;
        p[1] = u_Temp.bit.byte1;
        p[2] = u_Temp.bit.byte2;
        p[3] = u_Temp.bit.byte3;
}

//==================================================================================================
//| 函数名称 | DecodeFloat
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 解码FP32数据
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p -- 源缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 解码结果
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
FP32 DecodeFloat(INT8U *p)
{
        TYPECHANGE u_Temp;
        if(NULL == p)
        return 0;
        u_Temp.bit.byte0 = p[0];
        u_Temp.bit.byte1 = p[1];
        u_Temp.bit.byte2 = p[2];
        u_Temp.bit.byte3 = p[3];
        return(u_Temp.f_FloatData);
}

//==================================================================================================
//| 函数名称 | EncodeUlong
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 将INT32数据按照大小端格式编码到缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ul_Data -- 欲编码浮点数， p -- 编码缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
void EncodeUlong(INT32U ul_Data, INT8U *p)
{
        TYPECHANGE u_Temp;
        if(NULL == p)
        return ;
        u_Temp.ul_UlongData = ul_Data;
        p[0] = u_Temp.bit.byte0;
        p[1] = u_Temp.bit.byte1;
        p[2] = u_Temp.bit.byte2;
        p[3] = u_Temp.bit.byte3;
}

//==================================================================================================
//| 函数名称 | DecodeUlong
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 解码INT32U数据
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p -- 源缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 解码结果
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
INT32U DecodeUlong(INT8U *p)
{
        TYPECHANGE u_Temp;
        if(NULL == p)
        return 0;
        u_Temp.bit.byte0 = p[0];
        u_Temp.bit.byte1 = p[1];
        u_Temp.bit.byte2 = p[2];
        u_Temp.bit.byte3 = p[3];
        return(u_Temp.ul_UlongData);
}

//==================================================================================================
//| 函数名称 | EncodeLong
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 将INT32S数据按照大小端格式编码到缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | lg_Data -- 欲编码浮点数， p -- 编码缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
void EncodeLong(INT32S lg_Data, INT8U *p)
{
        TYPECHANGE u_Temp;
        if(NULL == p)
        return ;
        u_Temp.lg_LongData =  lg_Data;
        p[0] = u_Temp.bit.byte0;
        p[1] = u_Temp.bit.byte1;
        p[2] = u_Temp.bit.byte2;
        p[3] = u_Temp.bit.byte3;
}

//==================================================================================================
//| 函数名称 | DecodeLong
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 解码INT32S数据
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p -- 源缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 解码结果
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
INT32S DecodeLong(INT8U *p)
{
    TYPECHANGE u_Temp;
    if(NULL == p)
        return 0;
        u_Temp.bit.byte0 = p[0];
        u_Temp.bit.byte1 = p[1];
        u_Temp.bit.byte2 = p[2];
        u_Temp.bit.byte3 = p[3];
        return(u_Temp.lg_LongData);
}

//==================================================================================================
//| 函数名称 | EncodeUint
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 将INT16U数据按照大小端格式编码到缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | uin_Data -- 欲编码浮点数， p -- 编码缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
void EncodeUint(INT16U uin_Data, INT8U *p)
{
        TYPECHANGE2 u_Temp;
        if(NULL == p)
        return ;
        u_Temp.uin_UintData =  uin_Data;
        p[0] = u_Temp.bit.byte0;
        p[1] = u_Temp.bit.byte1;
}

//==================================================================================================
//| 函数名称 | DecodeUint
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 解码INT16U数据
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p -- 源缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 解码结果
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
INT16U DecodeUint(INT8U *p)
{
        TYPECHANGE2 u_Temp;
        if(NULL == p)
        return 0;
        u_Temp.bit.byte0 = p[0];
        u_Temp.bit.byte1 = p[1];
        return(u_Temp.uin_UintData);
}

//==================================================================================================
//| 函数名称 | EncodeInt
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 将INT16S数据按照大小端格式编码到缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | in_Data -- 欲编码浮点数， p -- 编码缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
void EncodeInt(INT16S in_Data, INT8U *p)
{
        TYPECHANGE2 u_Temp;
        if(NULL == p)
        return ;
        u_Temp.in_IntData =  in_Data;
        p[0] = u_Temp.bit.byte0;
        p[1] = u_Temp.bit.byte1;
}

//==================================================================================================
//| 函数名称 | DecodeInt
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 解码INT16S数据
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p -- 源缓冲区
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 解码结果
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
INT16S DecodeInt(INT8U *p)
{
        TYPECHANGE2 u_Temp;
        if(NULL == p)
        return 0;
        u_Temp.bit.byte0 = p[0];
        u_Temp.bit.byte1 = p[1];
        return(u_Temp.in_IntData);
}

//==================================================================================================
//| 函数名称 | CHKInstId
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 校验仪器ID字符串是否合法，据规范,仪器序列号使用12个ASC码显示。
//|          | ASCII可以是数字、26个大写字母、26个小写字母、“ ”、“-”、“(”、“)”、“.”。
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_data -- 待校验字符串地址, uch_len -- 待校验字符串长度
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | 0 -- 合法， 1 -- 非法
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | Gang,2009.04.22
//==================================================================================================
INT8U CHKInstId(INT8U *p_data, INT8U uch_len)
{
        INT8U i;
        INT8U uch_tmp;

        #define CHK_INST_ID_LEN	12
        if((p_data == NULL) || (uch_len != CHK_INST_ID_LEN))
        {
                return (1);
        }

        for(i = 0; i < uch_len; i++)
        {
                uch_tmp = p_data[i];
                //数字
                if((uch_tmp >= '0') && (uch_tmp <= '9'))
                {
                        continue;
                }
                //字母
                if(((uch_tmp >= 'a') && (uch_tmp <= 'z'))
                        ||((uch_tmp >= 'A') && (uch_tmp <= 'Z')))
                {
                        continue;
                }
                //特殊字符判断
                if((uch_tmp == ' ') || (uch_tmp == '-')
                        || (uch_tmp == '(') || (uch_tmp == ')')
                        || (uch_tmp == '.'))
                {
                        continue;
                }
                //非法字符
                break;
        }

        //字符串非法
        if(i != CHK_INST_ID_LEN)
        {
                return (1);
        }
        else
        {
                return 0;
        }
}

//==================================================================================================
//| 函数名称 | DecimalDigits
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 保留小数位数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | f_data：浮点数 uch_DecimalNum：保留小数位数
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | ygm,2010.02.06
//==================================================================================================
//Decimal:小数位数
FP32 DecimalDigits(FP32 f_data,INT8U uch_DecimalNum)
{
    FP32 f_t;
    INT32S i_data;

    if(1 == uch_DecimalNum)
    {
      i_data = (INT32S)(f_data * 10);
      f_t = i_data/10.0;
    }
    else if(2 == uch_DecimalNum)
    {
      i_data = (INT32S)(f_data * 100);
      f_t = i_data/100.0;
    }
    else if(3 == uch_DecimalNum)
    {
      i_data = (INT32S)(f_data * 1000);
      f_t = i_data/1000.0;
    }
    else
    {
      f_t = f_data;
    }

    return(f_t);
}

//==================================================================================================
//| 函数名称 | DecimalDigits
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 保留小数位数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 |
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | INT8U 0,over range,1:into range
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | ygm,2010.02.06
//==================================================================================================
//Decimal:小数位数
INT8U IsOverRange(FP32 f_Data,const FP32 f_Max,const FP32 f_Min)
{

    if(f_Data >f_Max || f_Data < f_Min)
        return 0;
    else
        return 1;
}





















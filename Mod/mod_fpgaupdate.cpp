//==================================================================================================
//| 文件名称 | Mod_FPGAUpdate.c
//|--------- |--------------------------------------------------------------------------------------
//| 文件描述 | FPGA升級for linux
//|--------- |--------------------------------------------------------------------------------------
//| 运行环境 | 所有C/C++语言编译环境，包括单片机编译器
//|--------- |--------------------------------------------------------------------------------------
//| 版权声明 | Copyright2017, 聚光科技(FPI)
//|----------|--------------------------------------------------------------------------------------
//|  版本    |  时间       |  作者     | 描述
//|--------- |-------------|-----------|------------------------------------------------------------
//|  V1.0    |2017.12.20   |  lyb       | 初版
//==================================================================================================

#include "mod_fpgaupdate.h"
#include <QDebug>
#include <unistd.h>
#include "Bsp/Bsp_SPI1.h"
//------------全局变量-----------------------

static INT8U uch_FPGAUpdateStatus = FPGAUPSTATUS_IDLE;
static INT8U uch_MCULinkFLASH = 0; //1 MCU connect FLASH 0 MCU disconnect FLASH
static INT32U ul_CalCRC = 0;
static INT32U ul_FileSize = 0;
static INT32U ul_FlashSize = 0;
static INT32U ul_CalRealCRC = 0;
static INT32U ul_FileCRC = 0;


//static INT32U WAITTimeout = FLASH_WAIT_TIMEOUT;
//CRC运算表
static const unsigned int  crc32_table[256]={
    0x00000000,  0x77073096,  0xee0e612c,  0x990951ba,  0x076dc419,  0x706af48f,
    0xe963a535,  0x9e6495a3,  0x0edb8832,  0x79dcb8a4,  0xe0d5e91e,  0x97d2d988,
    0x09b64c2b,  0x7eb17cbd,  0xe7b82d07,  0x90bf1d91,  0x1db71064,  0x6ab020f2,
    0xf3b97148,  0x84be41de,  0x1adad47d,  0x6ddde4eb,  0xf4d4b551,  0x83d385c7,
    0x136c9856,  0x646ba8c0,  0xfd62f97a,  0x8a65c9ec,  0x14015c4f,  0x63066cd9,
    0xfa0f3d63,  0x8d080df5,  0x3b6e20c8,  0x4c69105e,  0xd56041e4,  0xa2677172,
    0x3c03e4d1,  0x4b04d447,  0xd20d85fd,  0xa50ab56b,  0x35b5a8fa,  0x42b2986c,
    0xdbbbc9d6,  0xacbcf940,  0x32d86ce3,  0x45df5c75,  0xdcd60dcf,  0xabd13d59,
    0x26d930ac,  0x51de003a,  0xc8d75180,  0xbfd06116,  0x21b4f4b5,  0x56b3c423,
    0xcfba9599,  0xb8bda50f,  0x2802b89e,  0x5f058808,  0xc60cd9b2,  0xb10be924,
    0x2f6f7c87,  0x58684c11,  0xc1611dab,  0xb6662d3d,  0x76dc4190,  0x01db7106,
    0x98d220bc,  0xefd5102a,  0x71b18589,  0x06b6b51f,  0x9fbfe4a5,  0xe8b8d433,
    0x7807c9a2,  0x0f00f934,  0x9609a88e,  0xe10e9818,  0x7f6a0dbb,  0x086d3d2d,
    0x91646c97,  0xe6635c01,  0x6b6b51f4,  0x1c6c6162,  0x856530d8,  0xf262004e,
    0x6c0695ed,  0x1b01a57b,  0x8208f4c1,  0xf50fc457,  0x65b0d9c6,  0x12b7e950,
    0x8bbeb8ea,  0xfcb9887c,  0x62dd1ddf,  0x15da2d49,  0x8cd37cf3,  0xfbd44c65,
    0x4db26158,  0x3ab551ce,  0xa3bc0074,  0xd4bb30e2,  0x4adfa541,  0x3dd895d7,
    0xa4d1c46d,  0xd3d6f4fb,  0x4369e96a,  0x346ed9fc,  0xad678846,  0xda60b8d0,
    0x44042d73,  0x33031de5,  0xaa0a4c5f,  0xdd0d7cc9,  0x5005713c,  0x270241aa,
    0xbe0b1010,  0xc90c2086,  0x5768b525,  0x206f85b3,  0xb966d409,  0xce61e49f,
    0x5edef90e,  0x29d9c998,  0xb0d09822,  0xc7d7a8b4,  0x59b33d17,  0x2eb40d81,
    0xb7bd5c3b,  0xc0ba6cad,  0xedb88320,  0x9abfb3b6,  0x03b6e20c,  0x74b1d29a,
    0xead54739,  0x9dd277af,  0x04db2615,  0x73dc1683,  0xe3630b12,  0x94643b84,
    0x0d6d6a3e,  0x7a6a5aa8,  0xe40ecf0b,  0x9309ff9d,  0x0a00ae27,  0x7d079eb1,
    0xf00f9344,  0x8708a3d2,  0x1e01f268,  0x6906c2fe,  0xf762575d,  0x806567cb,
    0x196c3671,  0x6e6b06e7,  0xfed41b76,  0x89d32be0,  0x10da7a5a,  0x67dd4acc,
    0xf9b9df6f,  0x8ebeeff9,  0x17b7be43,  0x60b08ed5,  0xd6d6a3e8,  0xa1d1937e,
    0x38d8c2c4,  0x4fdff252,  0xd1bb67f1,  0xa6bc5767,  0x3fb506dd,  0x48b2364b,
    0xd80d2bda,  0xaf0a1b4c,  0x36034af6,  0x41047a60,  0xdf60efc3,  0xa867df55,
    0x316e8eef,  0x4669be79,  0xcb61b38c,  0xbc66831a,  0x256fd2a0,  0x5268e236,
    0xcc0c7795,  0xbb0b4703,  0x220216b9,  0x5505262f,  0xc5ba3bbe,  0xb2bd0b28,
    0x2bb45a92,  0x5cb36a04,  0xc2d7ffa7,  0xb5d0cf31,  0x2cd99e8b,  0x5bdeae1d,
    0x9b64c2b0,  0xec63f226,  0x756aa39c,  0x026d930a,  0x9c0906a9,  0xeb0e363f,
    0x72076785,  0x05005713,  0x95bf4a82,  0xe2b87a14,  0x7bb12bae,  0x0cb61b38,
    0x92d28e9b,  0xe5d5be0d,  0x7cdcefb7,  0x0bdbdf21,  0x86d3d2d4,  0xf1d4e242,
    0x68ddb3f8,  0x1fda836e,  0x81be16cd,  0xf6b9265b,  0x6fb077e1,  0x18b74777,
    0x88085ae6,  0xff0f6a70,  0x66063bca,  0x11010b5c,  0x8f659eff,  0xf862ae69,
    0x616bffd3,  0x166ccf45,  0xa00ae278,  0xd70dd2ee,  0x4e048354,  0x3903b3c2,
    0xa7672661,  0xd06016f7,  0x4969474d,  0x3e6e77db,  0xaed16a4a,  0xd9d65adc,
    0x40df0b66,  0x37d83bf0,  0xa9bcae53,  0xdebb9ec5,  0x47b2cf7f,  0x30b5ffe9,
    0xbdbdf21c,  0xcabac28a,  0x53b39330,  0x24b4a3a6,  0xbad03605,  0xcdd70693,
    0x54de5729,  0x23d967bf,  0xb3667a2e,  0xc4614ab8,  0x5d681b02,  0x2a6f2b94,
    0xb40bbe37,  0xc30c8ea1,  0x5a05df1b,  0x2d02ef8d,
};

//------------声明函数-----------------------
INT8U WriteFlash1Block(INT32U addr,INT8U *pdata);
INT8U ReadFlash1Block(INT32U addr,INT8U *pdata);
INT8U GetStartInfo(INT8U *p);
void msb_to_lsb(INT8U *in_byte, INT8U *out_byte);
void program_byte_msb(INT8U byte,INT8U cs_change);
void program_byte_lsb(INT8U byte,INT8U cs_change);
INT32U GetFlashSize(void);
INT8U read_byte_msb(INT8U *one_byte,INT8U cs_change);
INT8U read_byte_lsb(INT8U *one_byte,INT8U cs_change);
INT8U BulkErase(void);
void FPGAUpdate_Delay(INT32U ul_Count);
INT32U CheckCRC32(const INT8U *p, INT32U len,INT32U ul_PreValue,INT8U uch_FinishFlag);

//-----硬件支持相关函数声明-----
void MCULinkFLASH(void);
void FPGALinkFLASH(void);
void FPGAFLASH_GPIO_SET_IN(void);
void FPGAFLASH_GPIO_Config(void);
void MCULinkFPGAGPIO_Config();
INT8U SPI_FPGAFLASH_SendByte(INT8U byte);
INT8U SPI_FPGAFLASH_ReadByte(INT8U cs_change);

//------------------------------使用回调函数解析命令移植部分--------------------------------
//支持聚光协议回调函数，可以直接将此处部分移植到通信文件中
//未支持聚光协议回调函数 或 不支持聚光协议，请参考此处命令回调函数内容，结合《FPGA在线升级AS模式协议》 进行移植

//添加到表格中
//0x71,READ_ANSWER_UPDATE,0,1,Com71ReadUpdate,
//0x71,WRITE_ANSWER_UPDATE,8,1,Com71WriteUpdate,
//0x72,WRITE_ANSWER_UPDATE,1028,3,Com72WriteUpdate,
//0x73,READ_ANSWER_UPDATE,0,1,Com73ReadUpdate,
//0x74,READ_ANSWER_UPDATE,6,1027,Com74ReadUpdate

//==================================================================================================
//| 函数名称 | Com71ReadUpdate()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 查看flash是否erase完成
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U* ReceData,INT8U* SendData
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 错误码
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U Com71ReadUpdate(INT8U* ReceData, INT8U* SendData, INT16U *uip_SendDataLenth)
{
    if(EraseDone() == 0)
    {
        SendData[0] = 0x11;
    }
    else
    {
        SendData[0] = 0x00;
    }
    *uip_SendDataLenth = 1;
    return 0;
}

//==================================================================================================
//| 函数名称 | Com71WriteUpdate()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | flash整片擦除
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U* ReceData,INT8U* SendData
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 错误码
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U Com71WriteUpdate(INT8U* ReceData, INT8U* SendData, INT16U *uip_SendDataLenth)
{
    INT8U uch_Rtn;
    uch_Rtn = SetFPGAUpdateStart(ReceData);
    if(uch_Rtn == 0)
    {
        SendData[0] = 0x88;
    }
    else if(uch_Rtn == 1)
    {
        SendData[0] = 0x22; //表示flash容量小于要烧写的文件大小
    }
    else
    {
        SendData[0] = 0xaa;
    }
    *uip_SendDataLenth = 1;
    return 0;
}

//==================================================================================================
//| 函数名称 | Com72WriteUpdate()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 写入烧写数据
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U* ReceData,INT8U* SendData
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 错误码
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U Com72WriteUpdate(INT8U* ReceData, INT8U* SendData, INT16U *uip_SendDataLenth)
{
    INT8U uch_Rtn;
    INT16U uin_PackReturn;
    uch_Rtn = LoadUpdateFlowToFlash(ReceData,FPGA_UPDATE_SIZE,&uin_PackReturn);
    if (uch_Rtn == 0)
    {
        EncodeUint(uin_PackReturn,SendData);
        SendData[2] = 0x88;
    }
    else if (uch_Rtn == 2)
    {
        SendData[2] = 0x02;//表示CRC校验失败
    }
    else
    {
        SendData[2] = 0xaa;
    }
    *uip_SendDataLenth = 3;
    return 0;
}

//==================================================================================================
//| 函数名称 | Com73ReadUpdate()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 查询FPGA升级状态
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U* ReceData,INT8U* SendData
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 错误码
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U Com73ReadUpdate(INT8U* ReceData, INT8U* SendData, INT16U *uip_SendDataLenth)
{
    SendData[0] = LookFPGAUpdateStatus();
    *uip_SendDataLenth = 1;
    return 0;
}

//==================================================================================================
//| 函数名称 | Com74ReadUpdate()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 读取flash数据
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U* ReceData,INT8U* SendData
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 错误码
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U Com74ReadUpdate(INT8U* ReceData, INT8U* SendData, INT16U *uip_SendDataLenth)
{
//    qDebug("Read FPGA flash file");
    ReadFlashData(SendData,DecodeUint(ReceData+4));
    *uip_SendDataLenth = 1027;

    return 0;
}

//------------移植end----------------------------------------------------------------

//==================================================================================================
//| 函数名称 | FlashSelfTest()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 调试时测试flash
//|------------------------------------------------------------------------------------------------
//| 输入参数 | void
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 0 正确 1错误
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U FlashSelfTest(void)
{
    INT8U auch_Data[256];
    INT16U i;
    INT32U ul_Addr = 0x100000;

//    GetFlashSize();

    for(i=0;i<256;i++)
    {
        auch_Data[i] = i;
    }
    MCULinkFLASH();
    //BulkErase();

   //FPGAUpdate_Delay(1000000);

    while(1)
    {
//    FPGAUpdate_Delay(100);
    WriteFlash1Block(0x100000,auch_Data);

    ul_Addr += 256;

    qDebug("write Falsh block");
    if(ul_Addr>0)
        break;
    }

    ul_Addr = 0x100000;

    qDebug("datata %d,%d",auch_Data[11],auch_Data[12]);

    for(i=0;i<256;i++)
    {
        auch_Data[i] = 0;
    }
    while(1)
    {

//    FPGAUpdate_Delay(1);
    ReadFlash1Block(0x100000,auch_Data);
    ul_Addr += 256;

    if(ul_Addr>0)
        break;
    }

    for(i=0;i<256;i++)
    {
        if(auch_Data[i] != i)
        {
            break;
        }
    }
    qDebug("datata %d,%d",auch_Data[11],auch_Data[12]);

    FPGALinkFLASH();


    if(i>=256)
    {
        return 0; //读写正确
    }
    else
    {
        return 1; //读写错误
    }

}

//==================================================================================================
//| 函数名称 | GetStartInfo()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 获得写入升级文件的大小，和crc校验码
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U *p 信息数据
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U GetStartInfo(INT8U *p)
{
    ul_FileSize = DecodeUlong(p);
    ul_FileCRC = DecodeUlong(p+4);
    return 0;
}

//==================================================================================================
//| 函数名称 | GetFlashSize()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 获取flash的大小
//|------------------------------------------------------------------------------------------------
//| 输入参数 | void
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT32U flashsize
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT32U GetFlashSize(void)
{

    INT8U silicon_ID;


    program_byte_msb(READ_SILICON_ID,true);
    program_byte_msb(0x00,true); //DummyBytes
    program_byte_msb(0x00,true);
    program_byte_msb(0x00,true);
    read_byte_msb(&silicon_ID,false);


    if(silicon_ID == EPCS1_ID)
    {
        ul_FlashSize = 1<<20;
    }
    else if(silicon_ID == EPCS4_ID)
    {
        ul_FlashSize = 4<<20;
    }
    else if(silicon_ID == EPCS16_ID)
    {
        ul_FlashSize = 16<<20;
    }
    else if(silicon_ID == EPCS64_ID)
    {
        ul_FlashSize = 64<<20;
    }
    else
    {
        program_byte_msb(CHECK_SILICON_ID,true);
        program_byte_msb(0x00,true); //DummyBytes
        program_byte_msb(0x00,true);
        read_byte_msb(&silicon_ID,false);
        if(silicon_ID == EPCS128_ID)
        {
            ul_FlashSize = 128<<20;
        }
        else
        {
            ul_FlashSize = 0;
        }
    }
    return ul_FlashSize;

}

//==================================================================================================
//| 函数名称 | SetFPGAUpdateStart()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 升级启动，先进行整片擦除
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U *p 信息数据
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 0正确 1错误
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U SetFPGAUpdateStart(INT8U *p)
{
    INT32U ul_FlashSize = 0;
    GetStartInfo(p);
    MCULinkFLASH();
    ul_FlashSize = GetFlashSize();
    if(ul_FlashSize!=0) //能够读到FLASH的ID才进行比较
    {
        if(ul_FlashSize < ul_FileSize) //如果要写入的文件太大了就报错
        {
            FPGALinkFLASH();
            return 1;
        }
    }
    BulkErase();
    uch_FPGAUpdateStatus = FPGAUPSTATUS_UPSTART;
    return 0;
}

//==================================================================================================
//| 函数名称 | LoadUpdateFlowToFlash()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 下载数据到flash
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U *puch_Data,写入数据 INT32U len,长度 INT16U *uin_CurPackBack当期包号
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 错误码
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U LoadUpdateFlowToFlash(INT8U *puch_Data,INT32U len,INT16U *uin_CurPackBack)
{
    INT32U ul_Addr = 0;
    INT32U ul_AddrBuf = 0;
    INT16U uin_TotalPack = 0;
    INT16U uin_CurPack = 0;
    INT8U i = 0;
    INT8U uch_BlockNum = 0;
    INT8U *puch_BlockBuf;
    INT8U test;
    static INT16U uin_PrePack = 0;
    uin_TotalPack = DecodeUint(puch_Data);
    uin_CurPack = DecodeUint(puch_Data+2);
    *uin_CurPackBack = uin_CurPack;

    if(uch_MCULinkFLASH == 0)
    {
        return 1;
    }
//    if(len < 256 + 4) //写入至少满足1个block
//    {
//        return 1;
//    }
    if(uin_CurPack>uin_TotalPack)
    {
        return 1;
    }
    if(uin_CurPack < 1)
    {
        return 1;
    }




    ul_AddrBuf = (uin_CurPack-1)*FPGA_UPDATE_SIZE;

    uch_BlockNum = len/256;
    for(i=0;i<uch_BlockNum;i++)
    {
        ul_Addr = ul_AddrBuf + i*256;
        puch_BlockBuf = puch_Data + 4 + i*256;
        if(WriteFlash1Block(ul_Addr,puch_BlockBuf)!=0)
        {
            return 1;
        }
    }

    uch_FPGAUpdateStatus = FPGAUPSTATUS_WAITDONE;

    if(uin_CurPack != uin_PrePack)
    {
        uin_PrePack = uin_CurPack;

        if(uin_CurPack == uin_TotalPack) //完成后标志fpga升级成功，让FPGA连接flash
        {
            ul_CalCRC = CheckCRC32(puch_Data + 4,FPGA_UPDATE_SIZE,ul_CalCRC,1);
            FPGALinkFLASH();
            uch_FPGAUpdateStatus  = FPGAUPSTATUS_UPDONE;
            uin_PrePack = 0;
            if(ul_CalCRC != ul_FileCRC)
            {
                return 2; //校验失败
            }
        }
        else if(uin_CurPack == 1)
        {
            ul_CalCRC = CheckCRC32(puch_Data + 4,FPGA_UPDATE_SIZE,0xffffffff,0);
        }
        else
        {
            ul_CalCRC = CheckCRC32(puch_Data + 4,FPGA_UPDATE_SIZE,ul_CalCRC,0);
        }
    }

    return 0;
}
//==================================================================================================
//| 函数名称 | LoadUpdateFlowToFlash()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 下载数据到flash
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U* ReceData,INT8U* SendData
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 错误码
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U ReadFlashData(INT8U *puch_Data,INT16U PrePackNum)
{
    INT32U ul_Addr = 0;
    INT32U ul_AddrBuf = 0;
    INT16U i = 0;
    INT8U ul_ReadFinish = 0;
    INT8U *p;

    if(PrePackNum == 0)
    {
        MCULinkFLASH();
        ul_FlashSize = GetFlashSize();
    }
    ul_AddrBuf = (PrePackNum)*FPGA_UPDATE_SIZE;

    for(i=0;i<4;i++)
    {
        ul_Addr = ul_AddrBuf + i*256;
        p = puch_Data + 3 + i*256;
        if(ReadFlash1Block(ul_Addr,p)!=0)
        {
            FPGALinkFLASH();  //读出错的时候直接取消读操作并恢复FPGA运行状态
            *puch_Data = 0xaa;
            return 1;
        }
    }

    for(i=0;i<4*256;i++)
    {

        if(*(puch_Data+3+i) != 0xff)
        {
            break;
        }
    }

    if(ul_FlashSize!=0) //能读到FLASHSIZE的再使用该功能，如果无法获取FLASH size 那么请 用户自己控制 下载的filesize 小于 flash容量
    {
        if((PrePackNum+1)*4*256 >= ul_FlashSize)
        {
            ul_ReadFinish = 1;
        }
        else
        {
            ul_ReadFinish = 0;
        }
    }

    if(i >= 4*256)
    {
        ul_ReadFinish = 1;
    }
    else
    {
        ul_ReadFinish = 0;
    }


    if(ul_ReadFinish == 1)
    {
        *puch_Data = 0x11;
        FPGALinkFLASH();
    }
    else
    {
        *puch_Data = 0x00;
    }
    EncodeUint(PrePackNum+1,puch_Data+1);


    return 0;
}
//==================================================================================================
//| 函数名称 | ReadFlash1Block()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 读取一个block的数据
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT32U addr,地址 INT8U *pdata 读到的数据
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 错误码
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U ReadFlash1Block(INT32U addr,INT8U *pdata)
{
    INT16U i;
    INT8U uch_Status;


    program_byte_msb(READ_BYTES,true);
    program_byte_msb(((addr & 0xFF0000)>>16),true);
    program_byte_msb(((addr & 0x00FF00)>>8),true);
    program_byte_msb((addr & 0xFF),true);

//    for(i=0;i<255;i++) //单个读
//    {
//        read_byte_lsb((pdata+i),true);
//    }
//    read_byte_lsb((pdata+255),false);


    //整片读
    INT8U rx[256];
    INT8U tx[256];
    for(i=0;i<256;i++)
    {
        tx[i] = 0xff;
    }
    Spi_SendMultByte(tx,rx,256,false);
    for(i=0;i<256;i++)
    {
        msb_to_lsb(rx+i,pdata+i);
    }



    return 0;
}

//==================================================================================================
//| 函数名称 | WriteFlash1Block()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 写入一个block的数据
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT32U addr,地址 INT8U *pdata 写入的数据
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U 错误码
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U WriteFlash1Block(INT32U addr,INT8U *pdata)
{
    INT16U i;
    INT8U uch_Status;
    INT32U WAITTimeout = FLASH_WAIT_TIMEOUT;

//    program_byte_msb(WRITE_ENABLE,false);

////  块擦除

//    program_byte_msb(ERASE_SECTOR,true);
//    program_byte_msb(((addr & 0xFF0000)>>16),true);
//    program_byte_msb(((addr & 0x00FF00)>>8),true);
//    program_byte_msb((addr & 0xFF),false);

////   等待块擦除完成

//    program_byte_msb(READ_STATUS,true);
//    read_byte_msb(&uch_Status,true);

//    while(uch_Status&0x01)
//    {
//        read_byte_msb(&uch_Status,true);
//        FPGAUpdate_Delay(100000);
//    }
//    read_byte_msb(&uch_Status,false);


    //进行块写


    program_byte_msb(WRITE_ENABLE,false);

    program_byte_msb(PAGE_PROGRAM,true);
    program_byte_msb(((addr & 0xFF0000)>>16),true);
    program_byte_msb(((addr & 0x00FF00)>>8),true);
    program_byte_msb((addr & 0xFF),true);

//    for(i=0;i<255;i++)
//    {
//        program_byte_lsb(*(pdata+i),true);
//    }
//    program_byte_lsb(*(pdata+255),false);

    INT8U rx[256];
    INT8U tx[256];
    for(i=0;i<256;i++)
    {
        msb_to_lsb(pdata+i,tx+i);
    }
    Spi_SendMultByte(tx,rx,256,false);


    //等待写结束

    program_byte_msb(READ_STATUS,true);
    read_byte_msb(&uch_Status,true);
    while(uch_Status&0x01)
    {
        if((WAITTimeout--) == 0)
        {
            qDebug("Timeout");
            return 1;
        }
        read_byte_msb(&uch_Status,true);
        FPGAUpdate_Delay(1000);
    }
    read_byte_msb(&uch_Status,false);

    return 0;
}

//==================================================================================================
//| 函数名称 | BulkErase()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 整片擦除，不包含等待完成程序
//|------------------------------------------------------------------------------------------------
//| 输入参数 | void
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U BulkErase(void)  //进行 erase， 调用独立函数进行调用
{
    if(uch_MCULinkFLASH == 0)
    {
        return 1;
    }

    program_byte_msb(WRITE_ENABLE,false);

    program_byte_msb(ERASE_BULK,false);

    FPGAUpdate_Delay(100);  //大约延100us

    qDebug("bulk ok");
    return 0;
}

//==================================================================================================
//| 函数名称 | EraseDone()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 查询flash状态是否空闲
//|------------------------------------------------------------------------------------------------
//| 输入参数 | void
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U EraseDone(void)
{
    INT8U uch_Status = 0;

    program_byte_msb(READ_STATUS,true);
    read_byte_msb(&uch_Status,false);

    if(uch_Status&0x01)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
//==================================================================================================
//| 函数名称 | LookFPGAUpdateStatus()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 返回fpga升级状态
//|------------------------------------------------------------------------------------------------
//| 输入参数 | void
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U LookFPGAUpdateStatus(void)
{
    return uch_FPGAUpdateStatus;
}
//==================================================================================================
//| 函数名称 | FPGAUpdateInit()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | FPGA升级相关的初始化
//|------------------------------------------------------------------------------------------------
//| 输入参数 | void
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
void FPGAUpdateInit(void)
{
    SPI1Init();
    //qDebug("------------------------------FPGA FLASH TEST ---start");
    FPGALinkFLASH();  //MCU 与 FLASH 连接的引脚配置   MCU上电配置 为 FPGA与FLASH连接模式
//    MCULinkFLASH();

//    qDebug("------------------------------FPGA FLASH TEST ---start");
//    INT8U uch_Temp = FlashSelfTest();
//    qDebug("------------------------------FPGA FLASH TEST %d----------------------------",uch_Temp);
    FPGAUpdate_Delay(1000000);  //大约延时1s
}

void FPGAUpdate_Delay(INT32U ul_Count)
{
    //for(; ul_Count != 0; ul_Count--);
    usleep(ul_Count);
}

//==================================================================================================
//| 函数名称 | msb_to_lsb()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 高位再前和低位在前的转换，可以互相转。
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U *in_byte, 待转字节 INT8U *out_byte 转换后的字节
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
void msb_to_lsb(INT8U *in_byte, INT8U *out_byte)
{
    INT8U       mask;
    INT8U       i;
    INT8U     temp;

    *out_byte = 0x00;


    for ( i = 0; i < 8; i++ )
    {
        temp = *in_byte >> i;
        mask = 0x80 >> i;

        if(temp & 0x01)
        {
            *out_byte |= mask;
        }

    }
}


//==================================================================================================
//| 函数名称 | program_byte_lsb()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 写入1byte数据低位在前
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U byte,INT8U cs_change
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
void program_byte_lsb(INT8U byte,INT8U cs_change)
{
    INT8U data_byte = 0;
    msb_to_lsb(&byte, &data_byte);
    program_byte_msb(data_byte,cs_change);
//     FPGAUpdate_Delay(100);
}
//==================================================================================================
//| 函数名称 | program_byte_msb()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 写入1byte数据高位在前
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U byte,INT8U cs_change
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
void program_byte_msb(INT8U byte,INT8U cs_change)
{
    Spi_Send1Byte(byte,cs_change);
    //FPGAUpdate_Delay(10);
}

//==================================================================================================
//| 函数名称 | read_byte_lsb()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 读取1byte数据低位在前
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U byte,INT8U cs_change
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U read_byte_lsb(INT8U *one_byte,INT8U cs_change)
{
    INT8U data_byte = 0;

    read_byte_msb(&data_byte,cs_change);
    //After conversion, MSB will come in first
    msb_to_lsb(&data_byte, one_byte);
    return 0;
}
//==================================================================================================
//| 函数名称 | read_byte_msb()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 读取1byte数据高位在前
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U byte,INT8U cs_change
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U read_byte_msb(INT8U *one_byte ,INT8U cs_change)
{
    *one_byte = SPI_FPGAFLASH_ReadByte(cs_change);
//    FPGAUpdate_Delay(100);
    return 0;
}

//==================================================================================================
//| 函数名称 | CheckCRC32()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | CRC校验
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U byte,INT8U cs_change
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT32U CheckCRC32(const INT8U *p, INT32U len,INT32U ul_PreValue,INT8U uch_FinishFlag)
{
    INT32U ii=0;
    INT32U crc;
    INT32U m_crc;
    m_crc = ul_PreValue;
    for(ii=0; ii <len; ii++)
    {
        m_crc = crc32_table[( m_crc^(*(p+ii)) ) & 0xff] ^ (m_crc >> 8);
    }
    if(uch_FinishFlag == 1)
    {
        crc= ~m_crc;
    }
    else
    {
        crc= m_crc;
    }
    return crc;
}


//-------------------------------------硬件相关-------------------------------------------
//==================================================================================================
//| 函数名称 | MCULinkFLASH()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | MCU连接flash
//|------------------------------------------------------------------------------------------------
//| 输入参数 | void
//|------------------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
void MCULinkFLASH(void)
{
    Spi_IOMode(0);
    gpio_ctl(FPGA_EN,1,1); //关闭FPGA


//    FPGAUpdate_Delay(2);  //大约延时2us
    //初始化 MCU与 FLASH的引脚

    //FPGAFLASH_GPIO_Config();
//    gpio_ctl(FPGA_ASDO,1,1);
//    gpio_ctl(FPGA_DCLK,1,1);
//    gpio_ctl(FPGA_NCSO,1,1);



//    FPGAFLASH_SET_CS();
    uch_MCULinkFLASH = 1;
}
//==================================================================================================
//| 函数名称 | MCULinkFLASH()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | FPGA连接flash
//|------------------------------------------------------------------------------------------------
//| 输入参数 | void
//|------------------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
void FPGALinkFLASH(void)
{
//    FPGAFLASH_GPIO_SET_IN(); //FLASH SPI设为高阻态
    FPGAUpdate_Delay(2);  //大约延时2us

    //设置 NCONFIG_ or FPGA_EN power 为 关闭 使FPGA 退出复位状态 启动自我配置
    Spi_IOMode(1);
    gpio_ctl(FPGA_EN,1,0);


     uch_MCULinkFLASH = 0;

}


//==================================================================================================
//| 函数名称 | FPGAFLASH_GPIO_SET_IN()
//|------------------------------------------------------------------------------------------------
//| 函数功能 |
//|------------------------------------------------------------------------------------------------
//| 输入参数 | void
//|------------------------------------------------------------------------------------------------
//| 返回参数 | void
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
void FPGAFLASH_GPIO_SET_IN(void) //high z or in state
{
//    gpio_ctl(FPGA_ASDO,0,0);
//    gpio_ctl(FPGA_DCLK,0,0);
//    gpio_ctl(FPGA_NCSO,0,0);
//    gpio_ctl(FPGA_DATA0,0,0);
}


//==================================================================================================
//| 函数名称 | SPI_FPGAFLASH_SendByte()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | IO口模拟的SPI 这边没有用
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U byte
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U SPI_FPGAFLASH_SendByte(INT8U byte)
{
   INT8U uch_rec = 0;
   INT8U i;

    for ( i = 0; i < 8; i++ )
    {
        FPGAFLASH_CLR_CLK();
        if ( byte & (0x80 >> i) )
        {
            FPGAFLASH_SET_SDO();
        }
        else
        {
            FPGAFLASH_CLR_SDO();
        }
        //FPGAUpdate_Delay(1);  //大约延2us

        if (FPGAFLASH_SDI_DAT())
        {
            uch_rec |= (0x80 >> i);
        }
        FPGAFLASH_SET_CLK();
        //FPGAUpdate_Delay(1);  //大约延时2us
    }
    return uch_rec;
}

//==================================================================================================
//| 函数名称 | SPI_FPGAFLASH_ReadByte()
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 读取一个数据
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U cs_change
//|------------------------------------------------------------------------------------------------
//| 返回参数 | INT8U
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lyb,2020.02.30
//==================================================================================================
INT8U SPI_FPGAFLASH_ReadByte(INT8U cs_change)
{
  return (Spi_Send1Byte(0XFF,cs_change));
}




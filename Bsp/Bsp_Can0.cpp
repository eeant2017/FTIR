//==================================================================================================
//| 文件名称 | Bsp_Uart1.cpp
//|-----------------------------------------------------------------------------------------------
//| 文件描述 | 初始化模块
//|-----------------------------------------------------------------------------------------------
//| 运行环境 | 所有C/C++语言编译环境，包括单片机编译器
//|-----------------------------------------------------------------------------------------------
//| 版权声明 | Copyright2017, 聚光科技(FPI)
//|------------------------------------------------------------------------------------------------
//|  版本   |  时间       |  作者     | 描述
//|--------- -------------|-----------|------------------------------------------------------------
//|  V1.0   | 2019.05.07  |   cfh     | 初版
//==================================================================================================





//#include <linux/can.h>
#include <linux/can/raw.h>
#include "Bsp_Can0.h"
#include "Pub/Pub_Queue.h"
#include <QDebug>

static int fd_com;
static INT8U uch_SendEn = 0;
static INT8U sauch_TxFifo[CAN0FIFOSIZE];
static INT8U sauch_RxFifo[CAN0FIFOSIZE];

static CQueue m_TxFifo(sauch_TxFifo,sizeof(sauch_TxFifo));
static CQueue m_RxFifo(sauch_RxFifo,sizeof(sauch_RxFifo));

INT8U g_uchCanLock = 0;

extern void vMemDump(INT8U *pData, INT16U DataLen);

/*
 * 1Mb/s, 800kb/s, 500kb/s, 250kb/s, 125kb/s, 100kb/s, 50kb/s, 20kb/s, 10kb/s
 */
static void set_bitrate(int port, int bitrate)
{
    char cmd[64];
    sprintf(cmd,"ifconfig can%d down",port);
    system(cmd);
    qDebug("--------------------port %d------------------------0",port);
    if (port==0 || port==1)
    {
        qDebug("/home/fpi/ip link set can%d type can bitrate %d",port, bitrate*1000);
        //sprintf(cmd,"echo %d > /sys/devices/platform/FlexCAN.%d/bitrate",bitrate*1000,port);
        sprintf(cmd,"/home/fpi/ip link set can%d type can bitrate %d",port, bitrate*1000);
    }
    else if(port==2 || port ==3)
        sprintf(cmd,"/sbin/ip link set can%d type can bitrate %d",port, bitrate*1000);

    system(cmd);
    sprintf(cmd,"ifconfig can%d up",port);
    system(cmd);
}
static int open_can(int port, int family, int type, int proto, int bitrate)
{
    struct ifreq ifr;
    struct sockaddr_can addr;
    char *interface;
    int s;
    switch (port)
    {
    case 0:
        interface = "can0";
        break;
    case 1:
        interface = "can1";
        break;
    case 2:
        interface = "can2";
        break;
    case 3:
        interface = "can3";
        break;
    default:
        printf("Input port(%d) error! must be 0~3\n",port);
        exit(-1);
    }


    set_bitrate(port,bitrate);

    s = socket(family, type, proto);
    if (s < 0)
    {
        perror("socket");
        return 1;
    }
    printf("fdcom1= %d",s);
    addr.can_family = family;
    strcpy(ifr.ifr_name, interface);
    if (ioctl(s, SIOCGIFINDEX, &ifr))
    {
        perror("ioctl");
        return 1;
    }
    printf("fdcom2= %d",s);
    addr.can_ifindex = ifr.ifr_ifindex;

    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        perror("bind");
        return 1;
    }
    //fcntl(s,F_SETFL,O_NONBLOCK);//设置非阻塞模式
    printf("fdcom3= %d",s);
    printf("interface = %s, family = %d, type = %d, proto = %d, bitrate = %dk\n", interface, family, type, proto, bitrate);
    return s;
}
//can config
static void set_filter(int s, struct can_filter rfilter)
{
        if (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, &rfilter, sizeof(struct can_filter)) != 0)
        {
                perror("setsockopt");
                exit(1);
        }
}
//==================================================================================================
//| 函数名称 | Can0Init
//|-----------------------------------------------------------------------------------------------
//| 函数功能 | 初始化
//|-----------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | CFH 2019.5.7
//==================================================================================================
void Can0Init(void)
{

        int res;
        unsigned char buf[110];
        //int fd_com;


        struct can_frame frame ;
        struct can_filter rfilter;

        int port, bitrate, mode, opt;
        int s, nbytes, dlc = 0;
        int family = PF_CAN, type = SOCK_RAW, proto = CAN_RAW;


        int rtr = 0;

        port = 1;               //can端口 设置
        bitrate = 500;          //CAN波特率设置 500k

        rfilter.can_id = 0x02200800;
        rfilter.can_mask = 0x1FE00000;


        fd_com = open_can(port, family, type, proto, bitrate);

        //CAN的滤波设置
        //set_filter(fd_com, rfilter);
}

//==================================================================================================
//| 函数名称 | Uart1RxChar
//|-----------------------------------------------------------------------------------------------
//| 函数功能 | 片内UART1接收一个字节
//|------------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U *uch_Char
//|------------------------------------------------------------------------------------------------
//| 返回参数 | TRUE or FALSE
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
BOOL Can0RxChar(INT8U *puch_Char)
{
    if(NULL == puch_Char)
    {
        return FALSE;
    }
    if(FALSE == m_RxFifo.PopQueue(puch_Char)) //从接收缓冲区中弹出一个字节,若失败则开中断并返回
    {
      return FALSE;
    }
    return TRUE;
}


//==================================================================================================
//| 函数名称 | Uart1TxChar
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 写一个数据到发送缓冲区(不使能发送中断)
//|------------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 待发送的数据
//|------------------------------------------------------------------------------------------------
//| 返回参数 | TRUE or FALSE
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
BOOL Can0TxChar(INT8U uch_Char)
{
    //--qDebug("Can0TxChar-PushQueue-send data %x",uch_Char);
    if(FALSE == m_TxFifo.PushQueue(uch_Char)) //将数据压入发送FIFO,若失败则开中断并返回
    {
        qDebug()<<"Can0TxChar-->queue full";
        return FALSE;
    }
    return TRUE;
}

//==================================================================================================
//| 函数名称 | Uart1SendEnable
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 启动发送
//|------------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
void Can0SendEnable(void)
{
    //qDebug("can send enable");

    uch_SendEn = 1;
}
//==================================================================================================
//| 函数名称 | Uart1SendDisable
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 关闭发送
//|------------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
void Can0SendDisable(void)
{
    //qDebug("can send dis");
    uch_SendEn = 0;
}

//==================================================================================================
//| 函数名称 | Can0Rx
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 接收函数
//|------------------------------------------------------------------------------------------------
//| 调用模块 |
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
static BOOL Can0Rx(void)
{
    int res = 0;
    static int uin_count = 3001;
    struct can_frame frame ;
    INT8U uch_rxbuf[200] = {0};



    res =read(fd_com, &frame, sizeof(struct can_frame));

    if(res > 0)
    {
         //printf("can_id=0x%x,can_dlc=%d,data=%x\n",frame.can_id,frame.can_dlc,frame.data);
        qDebug("can_id=0x%x,can_dlc=%d\n",frame.can_id,frame.can_dlc);
        //--vMemDump(frame.data,8);

        for(int i =0; i<frame.can_dlc; i++)
        {

            if(FALSE == m_RxFifo.PushQueue(frame.data[i]))//将数据压入接受FIFO,若失败则调用发送FIFO满钩子函数
            {
                return FALSE;
            }
        }




    }


    return TRUE;
}

//==================================================================================================
//| 函数名称 | Uart1Tx
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 发送
//|------------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 |
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
static BOOL Can0Tx(void)
{
    int res = 0;
    INT8U uch_char = 0;
    INT8U uin_datalen = 0;
    INT8U uch_txbuf[20] = {0};
    struct can_frame frame;
    int extended = 1;

    while(uch_SendEn)
    {
        if(FALSE == m_TxFifo.PopQueue(&uch_char))                        //从发送缓冲区中弹出一个字节
        {
            //最後一個包
            frame.can_id = 0xf4;

            frame.can_dlc =uin_datalen;
            if (extended)
            {
                frame.can_id &= CAN_EFF_MASK;
                frame.can_id |= CAN_EFF_FLAG;
            }
            else
            {
                frame.can_id &= CAN_SFF_MASK;
            }
            memcpy(frame.data,uch_txbuf,uin_datalen);
            res = write(fd_com,&frame,sizeof(frame));
            if(res != uin_datalen)
            {
                qDebug("Can0Tx write err-1 %d\n",uin_datalen);
            }

            Can0SendDisable();
            break;
        }
        else
        {
            //qDebug("Can0Tx-->can senddata.\n");
            uch_txbuf[uin_datalen++] = uch_char;

            if(uin_datalen == 8)
            {
                //--qDebug("Can0Tx--> 8 can senddata:\n");
                //--vMemDump(uch_txbuf,uin_datalen);

                uin_datalen = 0;

                frame.can_id = 0xf4;
                frame.can_dlc =8;
                if (extended)
                {
                    frame.can_id &= CAN_EFF_MASK;
                    frame.can_id |= CAN_EFF_FLAG;
                }
                else
                {
                    frame.can_id &= CAN_SFF_MASK;
                }
                memcpy(frame.data,uch_txbuf,8);
                res = write(fd_com,&frame,sizeof(frame));
                if(res != uin_datalen)
                {
                   qDebug ("Can0Tx write err-2 %d\n",uin_datalen);
                }
                usleep(250);

            }
        }
    }


    return TRUE;
}
//==================================================================================================
//| 函数名称 | Uart1Process
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 串口处理函数
//|------------------------------------------------------------------------------------------------
//| 调用模块 |
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
void Can0TxProcess(void)
{
        Can0Tx();
}

//==================================================================================================
//| 函数名称 | Uart1Process
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 串口处理函数
//|------------------------------------------------------------------------------------------------
//| 调用模块 |
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
void Can0RxProcess(void)
{
     Can0Rx();
}


#include "App_CVacuComCommand.h"
#include "stdlib.h"
#include "App_App.h"
#include "Pro_FPGA.h"
#include "Pub_Alarm.h"

//碰撞池真空规
static INT8U uch_gReadVacu1[] = "@253PR1?;FF";//新的真空归的默认地址是253
static INT8U uch_gReadVacu2[] = "@252PR1?;FF";

#define	STATE_READ_VACU1	1
#define STATE_READ_VACU2	2
#define CHECK				0

//真空归通讯无应答
static INT8U uch_VacuCommErr  = 0;

//==================================================================================================
//| 函数名称 | Receive
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 接收函数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_frm -- 缓冲区指针, p_datLen -- 数据帧长度指针
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | -1 -- 操作异常， 0 -- 操作成功
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lxlll,2012.05.25
//==================================================================================================
CVacuComCommand::~CVacuComCommand()
{
        KillTimer(0);
};
//==================================================================================================
//| 函数名称 | Receive
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 接收函数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_frm -- 缓冲区指针, p_datLen -- 数据帧长度指针
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | -1 -- 操作异常， 0 -- 操作成功
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lxlll,2012.05.25
//==================================================================================================
CVacuComCommand::CVacuComCommand()
{
        SetTimer(0,1000);//初始化定时器，ID为0 500->1000
        uch_ReadVacuState = STATE_READ_VACU1;
        //uch_pvCurrentReBackFlag = 1;
        uch_pvReBackErrorCnt = 0;
}

//==================================================================================================
//| 函数名称 | SetVacuCommErr
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 接收函数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_frm -- 缓冲区指针, p_datLen -- 数据帧长度指针
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | -1 -- 操作异常， 0 -- 操作成功
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lxlll,2012.05.25
//==================================================================================================
void CVacuComCommand::SetVacuCommErr()
{
        uch_VacuCommErr = 1;
}

//==================================================================================================
//| 函数名称 | GetVacuCommErr
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 接收函数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_frm -- 缓冲区指针, p_datLen -- 数据帧长度指针
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | -1 -- 操作异常， 0 -- 操作成功
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lxlll,2012.05.25
//==================================================================================================
INT8U CVacuComCommand::GetVacuCommErr()
{
        return uch_VacuCommErr;
}

void CVacuComCommand::ClrVacuCommErr()
{
        uch_VacuCommErr = 0;
}
//==================================================================================================
//| 函数名称 | Receive
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 接收函数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_frm -- 缓冲区指针, p_datLen -- 数据帧长度指针
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | -1 -- 操作异常， 0 -- 操作成功
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lxlll,2012.05.25
//==================================================================================================
void CVacuComCommand::OnTimer(INT8U uch_iID)
{
        //使用定时器wxb20130719
        //1. 继承CTm类，重写OnTimer方法；
        //2. 设置关联，通过方法SetTimer(0,500)设置关联；



        switch(uch_iID)
        {
                case 0://与构造函数中设置的定时器ID一致
                {
                        switch(uch_ReadVacuState)
                        {
                                case STATE_READ_VACU1:
                                {
                                        puch_pvBKData = uch_gReadVacu1;

                                        Send(puch_pvBKData,sizeof(uch_gReadVacu1) - 1,SEND_HOST);

                                        puch_pvBKData = NULL;
                                        uch_pvReBackErrorCnt++;
                                        uch_ReadVacuState = CHECK;

                                        if(uch_pvReBackErrorCnt >= 6)
                                        {
                                                uch_pvReBackErrorCnt = 0;

                                                //六次无应答则报错
                                                SetVacuCommErr();
                                        }

                                }
                                break;
                                case STATE_READ_VACU2:
                                {
                                        puch_pvBKData = uch_gReadVacu2;

                                        Send(puch_pvBKData,sizeof(uch_gReadVacu2) - 1,SEND_HOST);

                                        puch_pvBKData = NULL;
                                        //uch_pvReBackErrorCnt++;
                                        uch_ReadVacuState = CHECK;

                                }
                                break;
                                case CHECK:
                                {
                                        uch_ReadVacuState = STATE_READ_VACU1;
                                }
                                break;

                                default:break;
                        }
                }
                break;
        }//switch(uch_iID)

        if(  1 == GetVacuCommErr())
        {
                //真空归通讯无应答
                cl_gApp.cl_puMnt.ProtectOfStandby(); //待机
                PushAlarmCode( cl_gApp.cl_puMnt.GetMntPara()->st_VacuCommErr.uch_FaultCode );
        }
        else
        {
                DelAlarmCode( cl_gApp.cl_puMnt.GetMntPara()->st_VacuCommErr.uch_FaultCode );
        }

        if((cl_gApp.cl_puMnt.GetMntPara()->st_VacuValue3.f_RealVal < 0.2) //9e-3
                && (cl_gApp.cl_puMnt.GetMntPara()->st_VacuValue1.f_RealVal < 0.2))
        {
                OperateRunFlag(SW_VACUMM_OK);
                cl_gApp.cl_puIOCtr.SetRunFlag(TRUE);
        }
        else
        {
                OperateRunFlag(SW_VACUMM_NO);
                cl_gApp.cl_puIOCtr.SetRunFlag(FALSE);
        }

        return;
}//OnTimer()

//==================================================================================================
//| 函数名称 | Receive
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 接收函数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_frm -- 缓冲区指针, p_datLen -- 数据帧长度指针
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | -1 -- 操作异常， 0 -- 操作成功
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lxlll,2012.05.25
//==================================================================================================
INT8S CVacuComCommand::Receive(void *pv_iData,INT16U uin_iLen)
{
        INT8U *puch_Data = (INT8U *)pv_iData;

        if(puch_Data == NULL)
        {
                return -127;
        }

        INT8S sch_Re = 0;
        INT8U uch_Command = 0;

        INT8U uch_Addr[3];
        memset(uch_Addr,0,sizeof(uch_Addr));
        memcpy(uch_Addr,puch_Data,3);
        uch_Command = atoi((const char*)uch_Addr);//【解析地址】
        //atoi函数：将字符串转化成整形数，可用于解析真空规的数据，根据小数点和E的位置，取出数字字符串，再转换
        this->SetCommand(uch_Command);

        if(uin_iLen < 2)
        {
                return -117;
        }

        sch_Re = DealCommand(puch_Data + 6, uin_iLen - 6);//去除【地址】【ACK】共6个字节

        if(sch_Re == 0)
        {
                uch_VacuCommErr = 0;//通信错误标志清除 lz2016.10.11
        }

        return sch_Re;
}

//==================================================================================================
//| 函数名称 | Send
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 删除底层接收到的数据帧中的0x82
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_frm -- 缓冲区指针, p_datLen -- 数据帧长度指针
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | -1 -- 操作异常， 0 -- 操作成功
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lxlll,2012.05.25
//==================================================================================================
INT8S CVacuComCommand::Send(void *pv_iData,INT16U uin_iLen,INT8U uch_iPipe)
{
        INT8S sch_Re;
        INT16U uin_Len = 0;

        sch_Re = pcl_pvPrePort->Send(pv_iData,uin_iLen,uch_iPipe);

        return sch_Re;
}

//==================================================================================================
//| 函数名称 | DealCommand
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 接收函数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | p_frm -- 缓冲区指针, p_datLen -- 数据帧长度指针
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | -1 -- 操作异常， 0 -- 操作成功
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lxlll,2012.05.25
//==================================================================================================
INT8S CVacuComCommand::DealCommand(INT8U *puch_iData,INT16U uin_iLen)
{
        INT8U *puch_Data = (INT8U *)puch_iData;

        if(puch_Data == NULL)
        {
                return -127;
        }

        INT8S sch_Re = 0;
        FP32 f_VacuValue = 0;


        switch(GetCommand())
        {
                case 253://253,,,,,3
                {
                        f_VacuValue = CountF(puch_Data,7);//应该使用uin_iLen，若存在长度不为7时，导致错误
                        cl_gApp.cl_puMnt.GetMntPara()->st_VacuValue3.f_RealVal = f_VacuValue;
                        uch_ReadVacuState = STATE_READ_VACU2;

                        ClrVacuCommErr();
                        uch_pvReBackErrorCnt = 0;
                }
                break;

                case 252://252,,,,,2//wxb 由FPGA读取（来宝真空规）
                {
                        f_VacuValue = CountF(puch_Data,7);
                        cl_gApp.cl_puMnt.GetMntPara()->st_VacuValue1.f_RealVal = f_VacuValue;
                        uch_ReadVacuState = STATE_READ_VACU1;
                }
                break;

                default:sch_Re = 9;break;
        }

        return sch_Re;
}

//==================================================================================================
//| 函数名称 | CountF
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 计算真空度
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------
//| 返回参数 | BOOL TRUE:处理过程没有错误，FALSE:有错误
//|----------|--------------------------------------------------------------------------------------
//| 函数设计 | lxlll 2010.09.2
//==================================================================================================
FP32 CVacuComCommand::CountF(INT8U* uch_Data,INT8U uch_Len)
{

        INT8U uch_lPoint = 0;
        INT8U uch_lE = 0;
        INT8U uch_lF = 0;
        FP32 f_lTemp = 0;
        INT8U j = 0,k = 1,l = 0;
        INT8U uch_Exp = 0;
        INT8U i = 0;
        INT8U uch_ExpFlag = 0;
        static FP32 P = 0.0;
        for(i = 0;i<uch_Len;i++)
        {
                if(uch_lPoint == 0)
                {
                        if(uch_Data[i] == '.')
                                uch_lPoint = 1;
                        else
                                f_lTemp = f_lTemp*10.0 + uch_Data[i]- 48;//0x30或48，'0'
                }
                else
                {
                        if(uch_lE == 0)
                        {
                                if(uch_Data[i] == 'E')
                                        uch_lE = 1;
                                else
                                {
                                        memset(&P,0,sizeof(P));
                                        // P = 0.00;
                                        if(k == 1)
                                                P = (1.0000)/(10.0);
                                        else
                                                P = (1.0000)/(100.0);
                                        P = ((FP32)(uch_Data[i]- 48))*P;
                                        f_lTemp =  f_lTemp +  P;
                                        k++;
                                }
                        }
                        else if(uch_lE == 1)
                        {
                                if(uch_lF == 0)
                                {
                                        if(uch_Data[i] == '+')
                                        {
                                                uch_lF = 1;j = 0;uch_ExpFlag = 1;continue;
                                        }
                                        else if(uch_Data[i] == '-')
                                        {
                                                uch_lF = 1;j = 0;uch_ExpFlag = 2; continue;
                                        }
                                        else
                                                return 0;
                                }
                                else if(uch_lF == 1)
                                {
                                        uch_Exp = uch_Exp*j +uch_Data[i]- 48;
                                        j++;
                                }
                        }

                }
        }
        if(uch_Exp != 0)
        {
                if(uch_ExpFlag == 1)
                {
                        for(i = 1;i<=uch_Exp;i++)
                        {
                                f_lTemp *= 10.0;
                        }
                }
                else if(uch_ExpFlag == 2)
                {
                        for(i = 1;i<=uch_Exp;i++)
                        {
                                f_lTemp /= 10.0;
                        }
                }


        }

        return f_lTemp;

}


//no more

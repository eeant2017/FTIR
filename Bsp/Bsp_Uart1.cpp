//==================================================================================================
//| 文件名称 | Bsp_Uart1.cpp
//|-----------------------------------------------------------------------------------------------
//| 文件描述 | 初始化模块
//|-----------------------------------------------------------------------------------------------
//| 运行环境 | 所有C/C++语言编译环境，包括单片机编译器
//|-----------------------------------------------------------------------------------------------
//| 版权声明 | Copyright2017, 聚光科技(FPI)
//|------------------------------------------------------------------------------------------------
//|  版本   |  时间       |  作者     | 描述
//|--------- -------------|-----------|------------------------------------------------------------
//|  V1.0   | 2018.07.11  |  zbb      | 初版
//==================================================================================================
#include "Bsp_Uart1.h"
#include "Pub/Pub_Queue.h"
#include "Bsp_Gpioctl.h"
static int fd_com;
static INT8U uch_SendEn = 0;
static INT8U sauch_TxFifo[UART1FIFOSIZE];
static INT8U sauch_RxFifo[UART1FIFOSIZE];

static CQueue m_TxFifo(sauch_TxFifo,sizeof(sauch_TxFifo));
static CQueue m_RxFifo(sauch_RxFifo,sizeof(sauch_RxFifo));


void Set485Input()
{

    gpio_ctl(UART1_DE,1,0);
    //qDebug("485de input");
}

void Set485Output()
{
    gpio_ctl(UART1_DE,1,1);
    //qDebug("485de output");
}

//==================================================================================================
//| 函数名称 | Uart1Init
//|-----------------------------------------------------------------------------------------------
//| 函数功能 | 初始化
//|-----------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
void Uart1Init(void)
{

    struct termios oldtio,newtio;

    fd_com = open(UART_COM,O_RDWR|O_NOCTTY);//fd_uart
    if (fd_com<0)
    {
        qDebug()<<"UART open err";
    }
    else
    {
        qDebug()<<"UART open suc";
    }
    tcgetattr(fd_com,&oldtio);
    bzero(&newtio,sizeof(newtio));

    newtio.c_cflag = UART_BAUDRATE|CS8|CLOCAL|CREAD;
    newtio.c_iflag |= IGNPAR;
    newtio.c_oflag =0;
    newtio.c_lflag =0;
    newtio.c_cc[VMIN] =0;
    newtio.c_cc[VTIME]=0;
    tcflush(fd_com,TCIFLUSH);
    tcsetattr(fd_com,TCSANOW,&newtio);
}

//==================================================================================================
//| 函数名称 | Uart1RxChar
//|-----------------------------------------------------------------------------------------------
//| 函数功能 | 片内UART1接收一个字节
//|------------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | INT8U *uch_Char
//|------------------------------------------------------------------------------------------------
//| 返回参数 | TRUE or FALSE
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
BOOL Uart1RxChar(INT8U *puch_Char)
{
    if(NULL == puch_Char)
    {
        return FALSE;
    }
    if(FALSE == m_RxFifo.PopQueue(puch_Char)) //从接收缓冲区中弹出一个字节,若失败则开中断并返回
    {

      return FALSE;
    }
    //qDebug("%x ",*puch_Char);
    return TRUE;
}


//==================================================================================================
//| 函数名称 | Uart1TxChar
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 写一个数据到发送缓冲区(不使能发送中断)
//|------------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 待发送的数据
//|------------------------------------------------------------------------------------------------
//| 返回参数 | TRUE or FALSE
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
BOOL Uart1TxChar(INT8U uch_Char)
{
    if(FALSE == m_TxFifo.PushQueue(uch_Char)) //将数据压入发送FIFO,若失败则开中断并返回
    {
        qDebug()<<"queue full";
        return FALSE;
    }
    //qDebug("%x ",uch_Char);
    return TRUE;
}

//==================================================================================================
//| 函数名称 | Uart1SendEnable
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 启动发送
//|------------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
void Uart1SendEnable(void)
{

    Set485Output();

    uch_SendEn = 1;

}
//==================================================================================================
//| 函数名称 | Uart1SendDisable
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 关闭发送
//|------------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
void Uart1SendDisable(void)
{
    uch_SendEn = 0;
}

//==================================================================================================
//| 函数名称 | Uart1Rx
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 接收
//|------------------------------------------------------------------------------------------------
//| 调用模块 |
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
static BOOL Uart1Rx(void)
{
    int res = 0;
    INT8U uch_rxbuf[UART1FIFOSIZE] = {0};

    res = read(fd_com,uch_rxbuf,UART1FIFOSIZE);
    for(int i =0; i<res; i++)
    {
        //qDebug("Uart1 rx char = %x",uch_rxbuf[i]);

        if(FALSE == m_RxFifo.PushQueue(uch_rxbuf[i]))//将数据压入接受FIFO,若失败则调用发送FIFO满钩子函数
        {

            return FALSE;
        }
    }

    return TRUE;
}

//==================================================================================================
//| 函数名称 | Uart1Tx
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 发送
//|------------------------------------------------------------------------------------------------
//| 调用模块 | 无
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 |
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
static BOOL Uart1Tx(void)
{
    int res = 0;
    INT8U uch_char = 0;
    INT8U uin_datalen = 0;
    INT8U uch_txbuf[110] = {0};

    while(uch_SendEn)
    {
        if(FALSE == m_TxFifo.PopQueue(&uch_char))                        //从发送缓冲区中弹出一个字节
        {
            Uart1SendDisable();
            break;
        }
        else
        {
            uch_txbuf[uin_datalen++] = uch_char;
            if(uin_datalen >= 100)
            {
                break;
            }
        }
    }
    if(uin_datalen > 0)
    {
        res = write(fd_com,uch_txbuf,uin_datalen);
        //qDebug("uart1 wite data num %d",uin_datalen);
        if(res != uin_datalen)
        {

            printf ("err %d\n",uin_datalen);
        }

        usleep(13000);
        Set485Input();
    }

    return TRUE;
}
//==================================================================================================
//| 函数名称 | Uart1Process
//|------------------------------------------------------------------------------------------------
//| 函数功能 | 串口处理函数
//|------------------------------------------------------------------------------------------------
//| 调用模块 |
//|------------------------------------------------------------------------------------------------
//| 输入参数 | 无
//|------------------------------------------------------------------------------------------------
//| 返回参数 | 无
//|------------------------------------------------------------------------------------------------
//| 函数设计 | zbb 2018.7.12
//==================================================================================================
void Uart1Process(void)
{
    while(1)
    {
        Uart1Rx();

        Uart1Tx();
    }


}
